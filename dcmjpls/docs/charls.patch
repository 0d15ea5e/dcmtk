diff -Nurpw libcharls.orig/CMakeLists.txt libcharls/CMakeLists.txt
--- libcharls.orig/CMakeLists.txt	2009-07-28 01:25:22.000000000 +0200
+++ libcharls/CMakeLists.txt	2009-07-28 10:45:56.000000000 +0200
@@ -1,25 +1,8 @@
-project(charls)
-cmake_minimum_required(VERSION 2.6)
+# declare additional include directories
+INCLUDE_DIRECTORIES(${dcmjpls_SOURCE_DIR}/libcharls)
 
+# create library from source files
+ADD_LIBRARY(charls header interface jpegls stdafx)
 
-# When user specify build type do not override settings:
-IF(NOT CMAKE_BUILD_TYPE)
-# The following compiler option are only meant for GCC:
-IF(CMAKE_COMPILER_IS_GNUCC)
-SET(CMAKE_CXX_FLAGS " -O3 -g" )
-ENDIF(CMAKE_COMPILER_IS_GNUCC)
-ENDIF(NOT CMAKE_BUILD_TYPE)
-
-OPTION(charls_BUILD_SHARED_LIBS "Build CharLS with shared libraries." OFF)
-SET(BUILD_SHARED_LIBS ${charls_BUILD_SHARED_LIBS})
-
-add_library(CharLS header.cpp  interface.cpp  jpegls.cpp  
-  stdafx.cpp
-  )
-
-
-add_executable(charlstest test/test.cpp test/time.cpp)
-target_link_libraries (charlstest CharLS)
-
-include(CTest)
-add_test(charlstest charlstest)
\ No newline at end of file
+# declare installation files
+INSTALL_TARGETS(${INSTALL_LIBDIR} charls)
diff -Nurpw libcharls.orig/Makefile.dep libcharls/Makefile.dep
--- libcharls.orig/Makefile.dep	1970-01-01 01:00:00.000000000 +0100
+++ libcharls/Makefile.dep	2009-07-28 10:49:16.000000000 +0200
@@ -0,0 +1,8 @@
+header.o: header.cc stdafx.h util.h interface.h header.h streams.h \
+  decoderstrategy.h processline.h colortransform.h encoderstrategy.h
+interface.o: interface.cc stdafx.h util.h interface.h header.h streams.h
+jpegls.o: jpegls.cc stdafx.h util.h interface.h streams.h header.h \
+  decoderstrategy.h processline.h colortransform.h encoderstrategy.h \
+  context.h contextrunmode.h lookuptable.h losslesstraits.h \
+  defaulttraits.h scan.h
+stdafx.o: stdafx.cc stdafx.h util.h interface.h
diff -Nurpw libcharls.orig/Makefile.in libcharls/Makefile.in
--- libcharls.orig/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ libcharls/Makefile.in	2009-07-28 10:48:59.000000000 +0200
@@ -0,0 +1,43 @@
+#
+#	Makefile for dcmjpls/libcharls
+#
+
+@SET_MAKE@
+
+SHELL = /bin/sh
+VPATH = @srcdir@:@top_srcdir@/include:@top_srcdir@/@configdir@/include
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+configdir = @top_srcdir@/@configdir@
+
+include $(configdir)/@common_makefile@
+
+LOCALINCLUDES =
+LOCALDEFS =
+
+objs = header.o interface.o jpegls.o stdafx.o
+
+library = libcharls.$(LIBEXT)
+
+all: $(library)
+
+install: all
+	$(configdir)/mkinstalldirs $(DESTDIR)$(libdir)
+	$(INSTALL_DATA) $(library) $(DESTDIR)$(libdir)/$(library)
+	$(RANLIB) $(DESTDIR)$(libdir)/$(library)
+
+$(library): $(objs)
+	$(AR) $(ARFLAGS) $@ $(objs)
+	$(RANLIB) $@
+
+clean:
+	rm -f $(objs) $(library) $(TRASH)
+
+distclean:
+	rm -f $(objs) $(library) $(DISTTRASH)
+
+
+dependencies:
+	$(CC) -MM $(defines) $(includes) $(CPPFLAGS) $(CXXFLAGS) *.cc  > $(DEP)
+
+include $(DEP)
diff -Nurpw libcharls.orig/decoderstrategy.h libcharls/decoderstrategy.h
--- libcharls.orig/decoderstrategy.h	2009-07-28 01:25:22.000000000 +0200
+++ libcharls/decoderstrategy.h	2009-07-28 12:55:02.000000000 +0200
@@ -5,10 +5,13 @@
 #ifndef CHARLS_DECODERSTATEGY
 #define CHARLS_DECODERSTATEGY
 
-
 #include "streams.h"
 #include "processline.h"
 
+#if defined(i386) || defined(__i386__) || defined(_M_IX86) || defined(__amd64__) || defined(_M_X64)
+#define ARCH_HAS_UNALIGNED_MEM_ACCESS /* TODO define this symbol for more architectures */
+#define USE_X86_ASSEMBLY
+#endif
 
 #ifdef _MSC_VER
 #include <intrin.h>
@@ -22,22 +25,65 @@ inline unsigned long long byteswap(unsig
 {	
 	return _byteswap_uint64(x);
 }
-#else
-
-inline unsigned int byteswap(unsigned int x)
+#elif defined(USE_X86_ASSEMBLY)
+// We can use x86 inline assembly!
+inline size_t byteswap(size_t x)
 {
 	asm("bswap %0" : "=r" (x) : "0" (x));
 	return x;
 }
-
-inline unsigned long long byteswap(unsigned long long x)
+#else
+// This function byteswaps a 4-byte unsigned integer
+inline unsigned int byteswap4(unsigned int x)
 {
-	asm("bswap %0" : "=r" (x) : "0" (x));
-	return x;
+	return (((x & 0x000000ff) << 24) |
+		((x & 0x0000ff00) <<  8) |
+		((x & 0x00ff0000) >>  8) |
+		((x & 0xff000000) >> 24));
 }
 
+inline size_t byteswap(size_t x)
+{
+	// The compiler should be able to optimize these ifs away
+	if (sizeof(size_t) == 4)
+		return byteswap4(x);
+	if (sizeof(size_t) != 8)
+		// This is not yet implemented!
+		assert(false);
+
+	// This variable should always be 32. The problem is that the following
+	// code would cause a warning on 32-bit arches, even though it is never
+	// executed. This is why we have to use this hack.
+	const unsigned int shift = sizeof(size_t) * 8 / 2;
+
+	unsigned int high = x >> shift;
+	unsigned int low = x & 0xffffffff;
+
+	size_t res = ((size_t) byteswap4(low)) << shift;
+	res |= byteswap4(high);
+
+	return res;
+}
 #endif 
 
+inline int is_big_endian()
+{
+	int i = 1;
+	char *p = (char *) &i;
+
+	// Little endian stores the least significant byte first in memory
+	// (0x01 in our case), big endian stores it last.
+	return (*p == 0);
+}
+
+inline size_t big_to_native_endian(size_t x)
+{
+	if (is_big_endian())
+		// x already is in our current endian (=big)
+		return x;
+	// We are on little endian, we need to swap some bytes
+	return byteswap(x);
+}
 
 class DecoderStrategy
 {
@@ -96,9 +142,17 @@ public:
 		  ASSERT(_validBits <=bufferbits - 8);
 
 		  // Easy & fast: if there is no 0xFF byte in sight, we can read without bitstuffing
-		  if (_pbyteCompressed < _pbyteNextFF)
+#ifndef ARCH_HAS_UNALIGNED_MEM_ACCESS
+		  // We can only dereference properly aligned pointers. This
+		  // checks if the pointer is properly aligned, if not we have
+		  // to take the slow path.
+		  const bufType needed_alignment_mask = sizeof(bufType) - 1;
+#else
+		  const bufType needed_alignment_mask = 0;
+#endif
+		  if (_pbyteCompressed < _pbyteNextFF && (((intptr_t)_pbyteCompressed) & needed_alignment_mask) == 0)
 		  {
-			  _readCache		 |= byteswap(*((bufType*)(_pbyteCompressed))) >> _validBits;
+			  _readCache		 |= big_to_native_endian(*((bufType*)_pbyteCompressed)) >> _validBits;
 
 			  int bytesToRead = (bufferbits - _validBits) >> 3; 			  
 			  _pbyteCompressed += bytesToRead;
@@ -161,7 +215,6 @@ public:
     		  pbyteNextFF++;
 		  }
 		  
-
 		  return pbyteNextFF - (sizeof(bufType)-1);
 	  }
 
diff -Nurpw libcharls.orig/encoderstrategy.h libcharls/encoderstrategy.h
--- libcharls.orig/encoderstrategy.h	2009-07-28 01:25:22.000000000 +0200
+++ libcharls/encoderstrategy.h	2009-07-28 13:27:59.000000000 +0200
@@ -85,6 +85,10 @@ protected:
 	void FlushStreamEnd()
 	{
 		Flush();
+		// if a 0xff was written, Flush() will force one unset bit anyway
+		if (_bFFWritten)
+			AppendToBitStream(0, (bitpos - 1) % 8);
+		else
 		AppendToBitStream(0,bitpos % 8);
 		ASSERT(bitpos % 8 == 0);
 		Flush();
diff -Nurpw libcharls.orig/header.cc libcharls/header.cc
--- libcharls.orig/header.cc	2009-07-28 01:25:22.000000000 +0200
+++ libcharls/header.cc	2009-07-28 13:09:07.000000000 +0200
@@ -533,7 +533,6 @@ void JLSOutputStream::AddScan(const void
 	_icompLast += 1;
 	_segments.push_back(EncodeStartOfScan(pparams,pparams->ilv == ILV_NONE ? _icompLast : -1));
 
-	Size size = Size(pparams->width, pparams->height);
 	int ccomp = pparams->ilv == ILV_NONE ? 1 : pparams->components;
 		_segments.push_back(new JpegImageDataSegment(pbyteComp, *pparams, _icompLast, ccomp));
 }
diff -Nurpw libcharls.orig/interface.cc libcharls/interface.cc
--- libcharls.orig/interface.cc	2009-07-28 01:25:22.000000000 +0200
+++ libcharls/interface.cc	2009-07-28 10:21:21.000000000 +0200
@@ -54,7 +54,9 @@ CHARLS_IMEXPORT JLS_ERROR JpegLsEncode(v
 	JlsParamaters info = *pparams;
 	if(info.bytesperline == 0)
 	{
-		info.bytesperline = info.width * ((info.bitspersample + 7)/8) * info.components;
+		info.bytesperline = info.width * ((info.bitspersample + 7)/8);
+		if (info.ilv != ILV_NONE)
+			info.bytesperline *= info.components;
 	}
 	
 	JLS_ERROR parameterError = CheckInput(pdataCompressed, cbyteBuffer, pdataUncompressed, cbyteUncompressed, &info);
diff -Nurpw libcharls.orig/jpegls.cc libcharls/jpegls.cc
--- libcharls.orig/jpegls.cc	2009-07-28 01:25:22.000000000 +0200
+++ libcharls/jpegls.cc	2009-07-28 10:14:11.000000000 +0200
@@ -6,7 +6,6 @@
 #include "streams.h"
 #include "header.h"
                
-
 #include <math.h>
 #include <limits>
 #include <vector>
diff -Nurpw libcharls.orig/scan.h libcharls/scan.h
--- libcharls.orig/scan.h	2009-07-28 01:25:22.000000000 +0200
+++ libcharls/scan.h	2009-07-28 12:53:04.000000000 +0200
@@ -746,7 +746,6 @@ void JlsCodec<TRAITS,STRATEGY>::DoScan(B
 			ptypeCur[-1]		= ptypePrev[0];
 			DoLine((PIXEL*) NULL); // dummy arg for overload resolution
 
-	
 			rgRUNindex[component] = RUNindex;
 			ptypePrev += pixelstride;
 			ptypeCur += pixelstride;
