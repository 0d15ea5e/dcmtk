/*
**
** Author: Andrew Hewett	Created: 4.11.95
**
** Program: mkdeftag.cc
**
** Purpose:
** Generate a C++ header defining symbolic names for DICOM Tags.
**
** Last Update:		$Author: hewett $
** Update Date:		$Date: 1996-03-20 16:44:06 $
** Source File:		$Source: /export/gitmirror/dcmtk-git/../dcmtk-cvs/dcmtk/dcmdata/libsrc/mkdeftag.cc,v $
** CVS/RCS Revision:	$Revision: 1.3 $
** Status:		$State: Exp $
**
** CVS/RCS Log at end of file
**
*/

#include "osconfig.h"    /* make sure OS specific configuration is included first */

#include <stdio.h>
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif
#include <string.h>
#include <ctype.h>
#include <time.h>
#ifdef HAVE_SYS_UTSNAME_H
#include <sys/utsname.h>
#endif


#include "dcdict.h"

static char*
convertToIdentifier(char* s)
{
    if (s == NULL) {
	return s;
    }
    int len = strlen(s);
    int i=0;
    char c;

    for (i=0; i<len; i++) {
	c = s[i];
	if (!(isalnum(c) || (c == '_'))) {
	    /* replace char with '_' */
	    s[i] = '_';
        }
    }
    return s;
}

static char
rangeRestriction2char(DcmDictRangeRestriction r)
{
    char c = ' ';
    if (r == DcmDictRange_Odd) {
	c = 'o';
    } else if (r == DcmDictRange_Even) {
	c = 'e';
    } else if (r == DcmDictRange_Unspecified) {
	c = 'u';
    }
    return c;
}

static void
printDefined(FILE* fout, const DcmDictEntry* e)
{
    int i;
    char buf[DCM_MAXDICTLINESIZE+1];
    const char* tagPrefix;

    if (e == NULL || e->getTagName() == NULL) 
	return;

    strcpy(buf, e->getTagName());

    convertToIdentifier(buf);

    tagPrefix = "#define DCM_";
    fputs(tagPrefix, fout); /* write out prefix */
    fputs(buf, fout); /* write out rest of name */

    int n = 48 - (strlen(tagPrefix) + strlen(buf));
    for (i=0; i<n; i++) {
	    putc(' ', fout);
    }

    fprintf(fout, " DcmTagKey(0x%04x, 0x%04x)",
	    e->getGroup(), e->getElement());

    if (e->isRepeating()) {
	fprintf(fout, " /* (0x%04x", e->getGroup());
	if (e->isRepeatingGroup()) {
	    if (e->getGroupRangeRestriction() != DcmDictRange_Even) {
		fprintf(fout, "-%c", 
			rangeRestriction2char(e->getGroupRangeRestriction()));
	    }
	    fprintf(fout, "-0x%04x", e->getUpperGroup());
	}
	fprintf(fout, ",0x%04x", e->getElement());
	if (e->isRepeatingElement()) {
	    if (e->getElementRangeRestriction() != DcmDictRange_Even) {
		fprintf(fout, "-%c", 
			rangeRestriction2char(e->getElementRangeRestriction()));
	    }
	    fprintf(fout, "-0x%04x", e->getUpperElement());
	}
	fprintf(fout, ") */");
    }
    fputs("\n", fout);
}

static char*
stripTrailing(char* s, char c)
{
    int i, n;

    if (s == NULL) return s;

    n = strlen(s);
    for (i = n - 1; (i >= 0) && (s[i] == c); i--)
        s[i] = '\0';
    return s;
}

static char*
getDateString(char* dateString, int maxLen)
{
    time_t systime = time(NULL);
    const char *ct = ctime(&systime);
    strncpy(dateString, ct, maxLen);
    stripTrailing(dateString, '\n');
    return dateString;
}

#ifdef HAVE_CUSERID
static char*
getUserName(char* userString, int maxLen)
{
    char* s;
    s = cuserid(NULL);
    return strncpy(userString, s, maxLen);
}
#elif HAVE_GETLOGIN
static char*
getUserName(char* userString, int maxLen)
{
    char* s;
    s = getlogin();
    if (s == NULL) s = "<no-utmp-entry>";
    return strncpy(userString, s, maxLen);
}
#else
static char*
getUserName(char* userString, int maxLen)
{
    char* s = "<unknown-user>";
    return strncpy(userString, s, maxLen);
}
#endif

#ifdef HAVE_UNAME
static char*
getHostName(char* hostString, int maxLen)
{
    struct utsname n;
    uname(&n);
    strncpy(hostString, n.nodename, maxLen);
    return hostString;
}
#elif HAVE_GETHOSTNAME
static char*
getHostName(char* userString, int maxLen)
{
    gethostname(userString, maxLen);
    return userString;
}
#else
static char*
getHostName(char* hostString, int maxLen)
{
    return strncpy(hostString, "localhost", maxLen);
}
#endif    

int main(int argc, char* argv[])
{
    char* progname = "mkdeftag";
    const DcmDictEntry* e = NULL;
    Pix p = 0;
    int i = 0;
    FILE* fout = NULL;

    /* clear out global data dictionary */
    dcmDataDict.clear();

    progname = argv[0];
    for (i=1; i<argc; i++) { 
        dcmDataDict.loadDictionary(argv[i]);
    }

    fout = stdout;

    fputs("/*\n", fout);
    fputs("** DO NOT EDIT THIS FILE !!!\n", fout);
    fputs("** It was generated automatically by:\n", fout);
#ifndef SUPRESS_CREATE_STAMP
    /* 
     * Putting the date in the file will confuse CVS/RCS 
     * if nothing has changed except the generation date.
     * This is only an issue if the header file is continually 
     * generated new.
     */
    fputs("**\n", fout);
    char tmpString[512];
    getUserName(tmpString, 512);
    fprintf(fout, "**   User: %s\n", tmpString);
    getHostName(tmpString, 512);
    fprintf(fout, "**   Host: %s\n", tmpString);
    char dateString[512];
    getDateString(dateString, 512);
    fprintf(fout, "**   Date: %s\n", dateString);
#endif
    fprintf(fout, "**   Prog: %s\n", progname);
    fputs("**\n", fout);
    if (argc > 1) {
	fprintf(fout, "** From: %s\n", argv[1]);
	for (i=2; i<argc; i++) {
	    fprintf(fout, "**       %s\n", argv[i]);
	}
    }
    fputs("**\n", fout);
    fputs("*/\n\n", fout);
    fputs("#ifndef DCDEFTAG_H\n", fout);
    fputs("#define DCDEFTAG_H\n\n", fout);
    fputs("#include \"dctagkey.h\"\n\n", fout);
#ifndef SUPRESS_CREATE_STAMP
    fprintf(fout, "#define DCM_DICT_DEFTAG_BUILD_DATE \"%s\"\n", dateString);
    fputs("\n", fout);
#endif
    /* generate the entries themselves */
    fputs("\n/*\n", fout);
    fputs("** Fixed Tags in assending (gggg,eeee) order.\n", fout);
    fprintf(fout, "** Number of entries: %d\n", 
	   dcmDataDict.numberOfNormalTagEntries());
    fputs("** Tags with a repeating component (repeating tags) are listed later.\n", fout);
    fputs("*/\n", fout);

    for (p = dcmDataDict.normalFirst(); p != 0; dcmDataDict.normalNext(p)) {
	e = dcmDataDict.normalContents(p);
	printDefined(fout, e);
    }


    fputs("\n/*\n", fout);
    fputs("** Tags where the group/element can vary (repeating tags).\n", 
	  fout);
    fprintf(fout, "** Number of entries: %d\n", 
	   dcmDataDict.numberOfRepeatingTagEntries());
    fputs("*/\n", fout);

    for (p=dcmDataDict.repeatingFirst(); 
	 p!=0; dcmDataDict.repeatingNext(p)) {
	e = dcmDataDict.repeatingContents(p);
	printDefined(fout, e);
    }

    fputs("\n#endif /* !DCDEFTAG_H */\n", fout);

    return 0;
}

/*
** CVS/RCS Log:
** $Log: mkdeftag.cc,v $
** Revision 1.3  1996-03-20 16:44:06  hewett
** Updated for revised data dictionary.  Repeating tags are now handled better.
** A linear list of repeating tags has been introduced with a subset ordering
** mechanism to ensure that dictionary searches locate the most precise
** dictionary entry.
**
** Revision 1.2  1996/03/12 15:21:23  hewett
** The repeating sub-dictionary has been split into a repeatingElement and
** a repeatingGroups dictionary.  This is a temporary measure to reduce the
** problem of overlapping dictionary entries.  A full solution will require
** more radical changes to the data dictionary insertion and search
** mechanims.
**
** Revision 1.1  1995/11/23 17:03:16  hewett
** Updated for loadable data dictionary.  Some cleanup (more to do).
**
**
*/
