/*
**
** Author: Andrew Hewett	Created: 4.11.95
**
** Program: mkdeftag.cc
**
** Purpose:
** Generate a C++ header defining symbolic names for DICOM Tags.
**
** Last Update:		$Author: hewett $
** Update Date:		$Date: 1995-11-23 17:03:16 $
** Source File:		$Source: /export/gitmirror/dcmtk-git/../dcmtk-cvs/dcmtk/dcmdata/libsrc/mkdeftag.cc,v $
** CVS/RCS Revision:	$Revision: 1.1 $
** Status:		$State: Exp $
**
** CVS/RCS Log at end of file
**
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <time.h>

#include "dcdict.h"

static char*
convertToIdentifier(char* s)
{
    if (s == NULL) {
	return s;
    }
    int len = strlen(s);
    int i=0;
    char c;

    for (i=0; i<len; i++) {
	c = s[i];
	if (!(isalnum(c) || (c == '_'))) {
	    /* replace char with '_' */
	    s[i] = '_';
        }
    }
    return s;
}

static void
printDefined(FILE* fout, const DcmDictEntry* e)
{
    int i;
    char buf[DCM_MAXDICTLINESIZE+1];
    const char* tagPrefix;

    if (e == NULL || e->getTagName() == NULL) 
	return;

    strcpy(buf, e->getTagName());

    convertToIdentifier(buf);

    tagPrefix = "#define DCM_";
    fputs(tagPrefix, fout); /* write out prefix */
    fputs(buf, fout); /* write out rest of name */

    int n = 48 - (strlen(tagPrefix) + strlen(buf));
    for (i=0; i<n; i++) {
	    putc(' ', fout);
    }

    fprintf(fout, " DcmTagKey(0x%04x, 0x%04x)\n",
	    e->getGroup(), e->getElement());

}

static char*
stripTrailing(char* s, char c)
{
    int i, n;

    if (s == NULL) return s;

    n = strlen(s);
    for (i = n - 1; (i >= 0) && (s[i] == c); i--)
        s[i] = '\0';
    return s;
}

static char*
getDateString(char* dateString)
{
    time_t systime = time(NULL);
    const char *ct = ctime(&systime);
    strcpy(dateString, ct);
    stripTrailing(dateString, '\n');
    return dateString;
}


int main(int argc, char* argv[])
{
    char* progname = "mkdeftag";
    const DcmDictEntry* e = NULL;
    Pix p = 0;
    int i = 0;
    FILE* fout = NULL;

    /* clear out global data dictionary */
    dcmDataDict.clear();

    progname = argv[0];
    for (i=1; i<argc; i++) { 
        dcmDataDict.loadDictionary(argv[i]);
    }

    fout = stdout;

    char dateString[128];
    getDateString(dateString);

    fputs("/*\n", fout);
    fputs("** DO NOT EDIT THIS FILE !!!\n", fout);
    fputs("** It was generated automatically by:\n", fout);
    fprintf(fout, "** Prog: %s\n", progname);
#ifdef DATE_STAMP_DICT
    /* 
     * Putting the date in the file will confuse CVS/RCS 
     * if nothing has changed except the generation date
     */
    fputs("**\n", fout);
    fprintf(fout, "** Date: %s\n", dateString);
#endif
    fputs("**\n", fout);
    if (argc > 1) {
	fprintf(fout, "** From: %s\n", argv[1]);
	for (i=2; i<argc; i++) {
	    fprintf(fout, "**       %s\n", argv[i]);
	}
    }
    fputs("**\n", fout);
    fputs("*/\n\n", fout);
    fputs("#ifndef DCDEFTAG_H\n", fout);
    fputs("#define DCDEFTAG_H\n\n", fout);
    fputs("#include \"dctagkey.h\"\n\n", fout);
#ifdef DATE_STAMP_DICT
    fprintf(fout, "#define DCM_DICT_DEFTAG_BUILD_DATE \"%s\"\n", dateString);
    fputs("\n", fout);
#endif
    /* generate the entries themselves */
    for (p = dcmDataDict.first(); p != 0; dcmDataDict.next(p)) {
	e = dcmDataDict.contents(p);
	printDefined(fout, e);
    }

    for (p=dcmDataDict.repeatingFirst(); 
	 p!=0; dcmDataDict.repeatingNext(p)) {
	e = dcmDataDict.repeatingContents(p);
	printDefined(fout, e);
    }

    fputs("\n#endif /* !DCDEFTAG_H */\n", fout);

    return 0;
}

/*
** CVS/RCS Log:
** $Log: mkdeftag.cc,v $
** Revision 1.1  1995-11-23 17:03:16  hewett
** Updated for loadable data dictionary.  Some cleanup (more to do).
**
**
*/
